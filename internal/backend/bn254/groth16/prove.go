// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package groth16

import (
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"

	"github.com/consensys/gnark/internal/backend/bn254/cs"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr/fft"

	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"

	"fmt"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/internal/utils"
	"math/big"
)

// Proof represents a Groth16 proof that was encoded with a ProvingKey and can be verified
// with a valid statement and a VerifyingKey
// Notation follows Figure 4. in DIZK paper https://eprint.iacr.org/2018/691.pdf
type Proof struct {
	Ar, Krs curve.G1Affine
	Bs      curve.G2Affine
}

// isValid ensures proof elements are in the correct subgroup
func (proof *Proof) isValid() bool {
	return proof.Ar.IsInSubGroup() && proof.Krs.IsInSubGroup() && proof.Bs.IsInSubGroup()
}

// GetCurveID returns the curveID
func (proof *Proof) GetCurveID() ecc.ID {
	return curve.ID
}

func Prove(r1cs *cs.R1CS, pk *ProvingKey, witness bn254witness.Witness, force bool) (*Proof, error) {
	if len(witness) != int(r1cs.NbPublicVariables-1+r1cs.NbSecretVariables) {
		return nil, fmt.Errorf("invalid witness size, got %d, expected %d = %d (public - ONE_WIRE) + %d (secret)", len(witness), int(r1cs.NbPublicVariables-1+r1cs.NbSecretVariables), r1cs.NbPublicVariables, r1cs.NbSecretVariables)
	}
	wireValues, h, err := computeWires(r1cs, pk, witness, force)
	if wireValues == nil || h == nil || err != nil {
		return nil, err
	}

	// sample random r and s
	var r, s big.Int
	var _r, _s, _kr fr.Element
	if _, err := _r.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := _s.SetRandom(); err != nil {
		return nil, err
	}
	_kr.Mul(&_r, &_s).Neg(&_kr)

	_r.FromMont()
	_s.FromMont()
	_kr.FromMont()
	_r.ToBigInt(&r)
	_s.ToBigInt(&s)

	// computes r[δ], s[δ], kr[δ]
	deltas := curve.BatchScalarMultiplicationG1(&pk.G1.Delta, []fr.Element{_r, _s, _kr})

	bs1 := computeBS1(pk, wireValues, deltas)
	ar := computeAR1(pk, wireValues, deltas)

	krs := computeKRS(r1cs, pk, wireValues, deltas, h, ar, &s, &r, bs1)
	bs2 := computeBS2(pk, &s, wireValues)
	proof := &Proof{}
	proof.Krs.FromJacobian(&krs)
	proof.Ar.FromJacobian(&ar)
	proof.Bs.FromJacobian(&bs2)
	return proof, nil
}

func computeBS2(pk *ProvingKey, s *big.Int, wireValues []fr.Element) curve.G2Jac {
	cpuSemaphore := ecc.NewCPUSemaphore(1)
	var Bs, deltaS curve.G2Jac
	Bs.MultiExp(pk.G2.B, wireValues, cpuSemaphore)
	deltaS.FromAffine(&pk.G2.Delta)
	deltaS.ScalarMultiplication(&deltaS, s)
	Bs.AddAssign(&deltaS)
	Bs.AddMixed(&pk.G2.Beta)
	return Bs
}

func computeBS1(pk *ProvingKey, wireValues []fr.Element, deltas []curve.G1Affine) curve.G1Jac {
	cpuSemaphore := ecc.NewCPUSemaphore(1)
	var bs1 curve.G1Jac
	bs1.MultiExp(pk.G1.B, wireValues, cpuSemaphore)
	bs1.AddMixed(&pk.G1.Beta)
	bs1.AddMixed(&deltas[1])
	return bs1
}

func computeAR1(pk *ProvingKey, wireValues []fr.Element, deltas []curve.G1Affine) curve.G1Jac {
	cpuSemaphore := ecc.NewCPUSemaphore(1)
	var ar curve.G1Jac
	ar.MultiExp(pk.G1.A, wireValues, cpuSemaphore)
	ar.AddMixed(&pk.G1.Alpha)
	ar.AddMixed(&deltas[0])
	return ar
}

func computeKRS(r1cs *cs.R1CS, pk *ProvingKey, wireValues []fr.Element, deltas []curve.G1Affine, h []fr.Element, ar curve.G1Jac, s *big.Int, r *big.Int, bs1 curve.G1Jac) curve.G1Jac {
	cpuSemaphore := ecc.NewCPUSemaphore(1)
	var krs, krs2, p1 curve.G1Jac
	krs2.MultiExp(pk.G1.Z, h, cpuSemaphore)
	krs.MultiExp(pk.G1.K, wireValues[r1cs.NbPublicVariables:], cpuSemaphore)
	krs.AddMixed(&deltas[2])
	krs.AddAssign(&krs2)
	p1.ScalarMultiplication(&ar, s)
	krs.AddAssign(&p1)
	p1.ScalarMultiplication(&bs1, r)
	krs.AddAssign(&p1)
	return krs
}

func computeH(a, b, c []fr.Element, domain *fft.Domain) []fr.Element {
	// H part of Krs
	// Compute H (hz=ab-c, where z=-2 on ker X^n+1 (z(x)=x^n-1))
	// 	1 - _a = ifft(a), _b = ifft(b), _c = ifft(c)
	// 	2 - ca = fft_coset(_a), ba = fft_coset(_b), cc = fft_coset(_c)
	// 	3 - h = ifft_coset(ca o cb - cc)

	n := len(a)

	// add padding to ensure input length is domain cardinality
	padding := make([]fr.Element, int(domain.Cardinality)-n)
	a = append(a, padding...)
	b = append(b, padding...)
	c = append(c, padding...)
	n = len(a)

	domain.FFTInverse(a, fft.DIF, 0)
	domain.FFTInverse(b, fft.DIF, 0)
	domain.FFTInverse(c, fft.DIF, 0)

	domain.FFT(a, fft.DIT, 1)
	domain.FFT(b, fft.DIT, 1)
	domain.FFT(c, fft.DIT, 1)

	var minusTwoInv fr.Element
	minusTwoInv.SetUint64(2)
	minusTwoInv.Neg(&minusTwoInv).
		Inverse(&minusTwoInv)

	// h = ifft_coset(ca o cb - cc)
	// reusing a to avoid unecessary memalloc
	utils.Parallelize(n, func(start, end int) {
		for i := start; i < end; i++ {
			a[i].Mul(&a[i], &b[i]).
				Sub(&a[i], &c[i]).
				Mul(&a[i], &minusTwoInv)
		}
	})

	// ifft_coset
	domain.FFTInverse(a, fft.DIF, 1)

	utils.Parallelize(len(a), func(start, end int) {
		for i := start; i < end; i++ {
			a[i].FromMont()
		}
	})

	return a
}

func computeWires(r1cs *cs.R1CS, pk *ProvingKey, witness bn254witness.Witness, force bool) ([]fr.Element, []fr.Element, error) {
	a := make([]fr.Element, r1cs.NbConstraints, pk.Domain.Cardinality)
	b := make([]fr.Element, r1cs.NbConstraints, pk.Domain.Cardinality)
	c := make([]fr.Element, r1cs.NbConstraints, pk.Domain.Cardinality)
	wireValues := make([]fr.Element, r1cs.NbInternalVariables+r1cs.NbPublicVariables+r1cs.NbSecretVariables)
	if err := r1cs.Solve(witness, a, b, c, wireValues); err != nil && !force {
		return nil, nil, err
	}
	for i := 0; i < len(wireValues); i++ {
		wireValues[i].FromMont()
	}
	var h []fr.Element
	//chHDone := make(chan struct{}, 1)
	h = computeH(a, b, c, &pk.Domain)
	return wireValues, h, nil
}
